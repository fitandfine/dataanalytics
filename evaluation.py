# -*- coding: utf-8 -*-
"""Evaluation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1byQzLLkcDWgw1dp_B9esPRo-mSyjGLYe
"""

# Code for uploading data
from google.colab import files
uploaded = files.upload()

# Load necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# Load the dataset
data = pd.read_csv('/content/dataset for assignment 2.csv')
data.head()

# Check for missing values
print(data.isnull().sum())

# Handle missing values (example: filling with mean for numerical columns only)
numerical_columns = ['Age', 'App Sessions', 'Distance Travelled (km)', 'Calories Burned']
data[numerical_columns] = data[numerical_columns].fillna(data[numerical_columns].mean())

# Encode categorical variables
categorical_columns = ['Gender', 'Activity Level', 'Location']
data = pd.get_dummies(data, columns=categorical_columns, drop_first=True)
data.head()

# Summary statistics
print(data.describe())

# Pairplot for visualizing relationships
sns.pairplot(data)
plt.show()

# Correlation matrix
plt.figure(figsize=(10, 8))
sns.heatmap(data.corr(), annot=True, cmap='coolwarm')
plt.show()

# Regression Analysis
X = data.drop('App Sessions', axis=1)
y = data['App Sessions']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Linear Regression
lr = LinearRegression()
lr.fit(X_train, y_train)
y_pred = lr.predict(X_test)

# Evaluate the regression model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print("Mean Squared Error:", mse)
print("R-squared:", r2)

# Clustering (K-Means)
kmeans = KMeans(n_clusters=3)
data['cluster'] = kmeans.fit_predict(X)

# Plot clusters
plt.scatter(data['Distance Travelled (km)'], data['Calories Burned'], c=data['cluster'])
plt.xlabel('Distance Travelled (km)')
plt.ylabel('Calories Burned')
plt.title('Clustering')
plt.show()

# Clustering evaluation (using inertia)
print('Inertia:', kmeans.inertia_)

# Discussion of implications for software engineering decision-making
print("\nImplications for Software Engineering Decision-Making:")
print(f"The regression model's Mean Squared Error (MSE) of {mse} and R-squared value of {r2} indicate how well the model predicts 'App Sessions' based on the features.")
print("A lower MSE and a higher R-squared value suggest a better fit, helping in understanding the key factors influencing app usage. This insight can guide feature enhancements and targeted interventions to improve user engagement.")
print("The K-Means clustering model groups users based on similar behavior patterns, which can be used to tailor user experiences and marketing strategies for different user segments. The inertia value provides an indication of how tightly the clusters are formed, with a lower value signifying better-defined clusters.")